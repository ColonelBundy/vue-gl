(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t(e.VueGL={},e.THREE)})(this,function(e,t){"use strict";var v=Math.PI;function i(e,t){return i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},i(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function r(){return r=a()?Reflect.construct:function(e,t,r){var s=[null];s.push.apply(s,t);var a=Function.bind.apply(e,s),n=new a;return r&&i(n,r.prototype),n},r.apply(null,arguments)}function s(e,t){return l(e)||d(e,t)||m()}function n(e){return o(e)||p(e)||c()}function o(e){if(Array.isArray(e)){for(var t=0,a=Array(e.length);t<e.length;t++)a[t]=e[t];return a}}function l(e){if(Array.isArray(e))return e}function p(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function d(e,t){var i=[],a=!0,r=!1,s=void 0;try{for(var n,o=e[Symbol.iterator]();!(a=(n=o.next()).done)&&(i.push(n.value),!(t&&i.length===t));a=!0);}catch(e){r=!0,s=e}finally{try{a||null==o["return"]||o["return"]()}finally{if(r)throw s}}return i}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function m(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}/**
   * Returns a parsed vector3 object.
   */function u(e){return e.isVector3?e:r(t.Vector3,n(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector2 object.
   */function g(e){return e.isVector2?e:r(t.Vector2,n(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed euler object.
   */function h(e){return e.isEuler?e:r(t.Euler,n(e.trim().split(/\s+/).map(function(e,t){return 3===t?e:parseFloat(e)})))}/**
   * Returns a parsed spherical object.
   */function f(e){return e.isSpherical?e:r(t.Spherical,n(e.trim().split(/\s+/).map(function(e){return parseFloat(e)}))).makeSafe()}/**
   * Returns a parsed array.
   */function y(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function b(e){return y(e).map(function(e){return g(e)})}var S={inject:{vglNamespace:{default:function(){var e,t=this,i=[],a=[];return{renderers:i,cameras:Object.create(null),scenes:Object.create(null),update:function(){e||(t.$nextTick(function(){a.forEach(function(e){e()}),i.forEach(function(e){e.render()}),e=!1}),e=!0)},beforeRender:a,geometries:Object.create(null),materials:Object.create(null),textures:Object.create(null),object3ds:Object.create(null)}}}},provide:function(){return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:Object.create(this.vglNamespace.geometries)},materials:{value:Object.create(this.vglNamespace.materials)},textures:{value:Object.create(this.vglNamespace.textures)},object3ds:{value:Object.create(this.vglNamespace.object3ds)}})}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},x=[String,Number],N=String,M=[String,t.Vector3],w=[String,t.Spherical],V=Boolean,L=[String,t.Euler],A=[String,t.Vector2],G=[String,Array],j=[String,Array],C={props:{/** The object's local position as a 3D vector. */position:M,/** The object's local rotation as a euler angle. */rotation:L,/** The object's local scale as a 3D vector. */scale:M,/** Whether the object gets rendered into shadow map. */castShadow:V,/** Whether the material receives shadows. */receiveShadow:V,/** Optional name of the object. */name:N},computed:{inst:function(){return new t.Object3D}},inject:{vglObject3d:{default:{}},vglNamespace:"vglNamespace"},provide:function(){var e=this;return{vglObject3d:{get inst(){return e.inst}}}},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},beforeDestroy:function(){var e=this.vglNamespace,t=this.inst,i=this.name;t.parent&&t.parent.remove(t),e.object3ds[i]===t&&delete e.object3ds[i],e.update()},watch:{inst:{handler:function(e,t){t&&t.parent&&t.parent.remove(t),this.vglObject3d.inst&&this.vglObject3d.inst.add(e),this.position&&e.position.copy(u(this.position)),this.rotation&&e.rotation.copy(h(this.rotation)),this.scale&&e.scale.copy(u(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow}),this.name!==void 0&&(this.vglNamespace.object3ds[this.name]=e)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst)},position:function(e){this.inst.position.copy(u(e))},rotation:function(e){this.inst.rotation.copy(h(e))},scale:function(e){this.inst.scale.copy(u(e))},castShadow:function(e){this.inst.castShadow=e},receiveShadow:function(e){this.inst.receiveShadow=e},name:function(e,t){var i=this.vglNamespace.object3ds,a=this.inst;i[t]===a&&delete i[t],i[e]=a}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},B={mixins:[C],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:M,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:w},computed:{inst:function(){return new t.Camera}},watch:{inst:{handler:function(e){if(this.vglNamespace.cameras[this.name]=e,this.orbitPosition||this.orbitTarget){var i;this.orbitTarget&&(i=u(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(f(this.orbitPosition)),i&&e.position.add(i)),e.lookAt(i||new t.Vector3)}},immediate:!0},name:function(e,t){var i=this.vglNamespace.cameras,a=this.inst;i[t]===a&&delete i[t],i[e]=a},orbitTarget:function(e){var t=u(e);this.orbitPosition&&this.inst.position.setFromSpherical(f(this.orbitPosition)).add(t),this.inst.lookAt(t)},orbitPosition:function(e){if(this.inst.position.setFromSpherical(f(e)),this.orbitTarget){var i=u(this.orbitTarget);this.inst.position.add(i),this.inst.lookAt(i)}else this.inst.lookAt(new t.Vector3)}},beforeDestroy:function(){var e=this.vglNamespace.cameras,t=this.inst;e[this.name]===t&&delete e[this.name]}},z={mixins:[C],props:{/** CSS style color of the light. */color:{type:N,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:x,default:1}},computed:{inst:function(){return new t.Light}},watch:{inst:{handler:function(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color:function(e){this.inst.color.setStyle(e)},intensity:function(e){this.inst.intensity=parseFloat(e)}}},R={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},D={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide},P={inject:["vglNamespace"],props:{/** Name of the material. */name:N,/** Defines which side of faces will be rendered. front, back or double. */side:{type:N,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:N,default:"no"}},computed:{inst:function(){return new t.Material}},watch:{inst:{handler:function(e){e.setValues({side:D[this.side],vertexColors:R[this.vertexColors]}),this.vglNamespace.materials[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.materials,a=this.inst;i[t]===a&&delete i[t],i[e]=a},side:function(e){this.inst.side=D[e]},vertexColors:function(e){this.inst.vertexColors=R[e]}},beforeDestroy:function(){var e=this.vglNamespace.materials,t=this.inst;e[this.name]===t&&delete e[this.name]},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},T={inject:["vglNamespace"],props:{/** Name of the component. */name:N,/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:G,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:G,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:G},computed:{inst:function(){return new t.BufferGeometry}},watch:{inst:{handler:function(e,i){if(this.positionAttribute){var a=i?i.getAttribute("position"):new t.BufferAttribute(new Float32Array(y(this.positionAttribute)),3);e.addAttribute("position",a)}if(this.colorAttribute){var r=i?i.getAttribute("color"):new t.BufferAttribute(new Float32Array(y(this.colorAttribute)),3);e.addAttribute("color",r)}if(this.normalAttribute){var s=i?i.getAttribute("normal"):new t.BufferAttribute(new Float32Array(y(this.normalAttribute)),3);e.addAttribute("normal",s)}i&&i.dispose(),this.vglNamespace.geometries[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.geometries,a=this.inst;i[t]===a&&delete i[t],i[e]=a},positionAttribute:function(e){var t=y(e),i=this.inst.getAttribute("position");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},colorAttribute:function(e){var t=y(e),i=this.inst.getAttribute("color");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},normalAttribute:function(e){var t=y(e),i=this.inst.getAttribute("normal");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0}},beforeDestroy:function(){var e=this.vglNamespace.geometries,t=this.inst;e[this.name]===t&&delete e[this.name],t.dispose()},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},F={mixins:[C],methods:{setMaterial:function(){var e=this.vglNamespace.materials,t=this.material,i=this.inst;e[t]&&(i.material=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMaterial)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMaterial;e.splice(e.indexOf(t),1)}},E={mixins:[F],methods:{setGeometry:function(){var e=this.vglNamespace.geometries,t=this.geometry,i=this.inst;e[t]&&(i.geometry=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setGeometry)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setGeometry;e.splice(e.indexOf(t),1)}},H={mixins:[P],methods:{setMap:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.map;i in e&&(t.map=e[i])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMap)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMap;e.splice(e.indexOf(t),1)}},O={mixins:[H],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The color map of the material. */map:N},computed:{inst:function(){return new t.MeshStandardMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},$={mixins:[E],props:{/** Name of the geometry, representing the line segment(s). */geometry:N,/** Name of the material for the line. */material:N},computed:{inst:function(){return new t.Line}},methods:{computeLineDistances:function(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},created:function(){this.vglNamespace.beforeRender.push(this.computeLineDistances)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.computeLineDistances;e.splice(e.indexOf(t),1)}},k={mixins:[T],props:{/** Radius of the cylinder at the top. */radiusTop:{type:x,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:x,default:1},/** Height of the cylinder. */height:{type:x,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:x,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:x,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:V,/** Start angle for first segment. */thetaStart:{type:x,default:0},/** The central angle of the circular sector. */thetaLength:{type:x,default:2*v}},computed:{inst:function(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},U={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},W={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},_={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},I={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},q={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},K={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking},Q={mixins:[T],computed:{inst:function(){return new t.ExtrudeBufferGeometry([],{})}}},X=Object.create(null),Y={mixins:[H],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The color map of the material. */map:N,/** Specular color of the material. */specular:{type:N,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:x,default:30}},computed:{inst:function(){return new t.MeshPhongMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},specular:function(e){this.inst.specular.setStyle(e)},shininess:function(e){this.inst.shininess=parseFloat(e)}}};e.VglNamespace=S,e.VglObject3d=C,e.VglScene={mixins:[C],computed:{inst:function(){return new t.Scene}},watch:{inst:{handler:function(e){this.vglNamespace.scenes[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.scenes,a=this.inst;i[t]===a&&delete i[t],i[e]=a}},beforeDestroy:function(){var e=this.vglNamespace.scenes,t=this.inst;e[this.name]===t&&delete e[this.name]}},e.VglCamera=B,e.VglRenderer={mixins:[S],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:N,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:V,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:V,/** Whether to perform antialiasing. */antialias:V,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:V,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:N,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:V,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:V,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:V,/** Name of the using camera. */camera:N,/** Name of the target scene. */scene:N,/** If set, use shadow maps in the scene. */shadowMapEnabled:V},computed:{inst:function e(){var e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e}},methods:{render:function(){var e=this.vglNamespace.scenes[this.scene],t=this.vglNamespace.cameras[this.camera];if(e&&t){if(t.isPerspectiveCamera){var i=this.$el.clientWidth/this.$el.clientHeight;t.aspect!==i&&(t.aspect=i,t.updateProjectionMatrix())}else if(t.isOrthographicCamera){var a=this.$el.clientWidth/2,r=this.$el.clientHeight/2;(t.right!==a||t.top!==r)&&(t.left=-a,t.right=a,t.top=r,t.bottom=-r,t.updateProjectionMatrix())}else throw new TypeError("Unknown camera type.");this.inst.render(e,t)}}},watch:{inst:function(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.vglNamespace.update()),t.dispose()}},created:function(){this.vglNamespace.renderers.push(this)},mounted:function(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.insertBefore(this.inst.domElement,this.$el.firstChild),this.vglNamespace.update()},beforeDestroy:function(){this.vglNamespace.renderers.splice(this.vglNamespace.renderers.indexOf(this),1),this.inst.dispose()},render:function(e){var t=this;return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%"},on:{load:function(e){e.target.contentWindow.addEventListener("resize",function(){t.inst.setSize(t.$el.clientWidth,t.$el.clientHeight),t.vglNamespace.update()},!1)}}},this.$slots.default)])}},e.VglPerspectiveCamera={mixins:[B],props:{/** Zoom factor of the camera. */zoom:{type:x,default:1},/** Camera frustum near plane. */near:{type:x,default:.1},/** Camera frustum far plane. */far:{type:x,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:x,default:50}},computed:{inst:function(){return new t.PerspectiveCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()},fov:function(e){this.inst.fov=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglGroup={mixins:[C],computed:{inst:function(){return new t.Group}}},e.VglLight=z,e.VglDirectionalLight={mixins:[z],computed:{inst:function(){return new t.DirectionalLight}}},e.VglAmbientLight={mixins:[z],computed:{inst:function(){return new t.AmbientLight}}},e.VglMaterial=P,e.VglPointsMaterial={mixins:[P],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The size of the points. */size:{type:x,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:V},computed:{inst:function(){return new t.PointsMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},size:function(e){this.inst.size=parseFloat(e)},disableSizeAttenuation:function(e){this.inst.sizeAttenuation=!e}}},e.VglGeometry=T,e.VglSphereGeometry={mixins:[T],props:{/** Sphere radius. */radius:{type:x,default:1},/** Number of horizontal segments. */widthSegments:{type:x,default:8},/** Number of vertical segments. */heightSegments:{type:x,default:6},/** Specify horizontal starting angle. */phiStart:{type:x,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:x,default:2*v},/** Specify vertical starting angle. */thetaStart:{type:x,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:x,default:v}},computed:{inst:function(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglMeshStandardMaterial=O,e.VglMesh={mixins:[E],props:{/** Name of the geometry, defining the object's structure. */geometry:N,/** Name of the material, defining the object's appearance. */material:N},computed:{inst:function(){return new t.Mesh}}},e.VglPoints={mixins:[E],props:{/** Name of the geometry, defining the object's structure. */geometry:N,/** Name of the material, defining the object's appearance. */material:N},computed:{inst:function(){return new t.Points}}},e.VglLineBasicMaterial={mixins:[P],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:V,/** The line thickness. */linewidth:{type:x,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:N,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:N,default:"round"}},computed:{inst:function(){return new t.LineBasicMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},linecap:function(e){this.inst.linecap=e},linejoin:function(e){this.inst.linejoin=e}}},e.VglLine=$,e.VglSprite={mixins:[F],props:{/** Name of the material, defining the object's appearance. */material:N},computed:{inst:function(){return new t.Sprite}}},e.VglBoxGeometry={mixins:[T],props:{/** Width of the sides on the X axis. */width:{type:x,default:1},/** Height of the sides on the Y axis. */height:{type:x,default:1},/** Depth of the sides on the Z axis. */depth:{type:x,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:x,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:x,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:x,default:1}},computed:{inst:function(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},e.VglCircleGeometry={mixins:[T],props:{/** Radius of the circle. */radius:{type:x,default:1},/** Number of segments (triangles). */segments:{type:x,default:8},/** Start angle for first segment. */thetaStart:{type:x,default:0},/** The central angle of the circular sector. */thetaLength:{type:x,default:2*v}},computed:{inst:function(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglLineSegments={mixins:[$],computed:{inst:function(){return new t.LineSegments}}},e.VglLineLoop={mixins:[$],computed:{inst:function(){return new t.LineLoop}}},e.VglConeGeometry={mixins:[k],props:{/** Radius of the cone at the base. */radius:{type:x,default:1}},computed:{inst:function(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglAxesHelper={mixins:[C],props:{/** Size of the lines representing the axes. */size:{type:x,default:1}},computed:{inst:function(){return new t.AxesHelper(parseFloat(this.size))}}},e.VglOrthographicCamera={mixins:[B],props:{/** Zoom factor of the camera. */zoom:{type:x,default:1},/** Camera frustum near plane. */near:{type:x,default:.1},/** Camera frustum far plane. */far:{type:x,default:2e3}},computed:{inst:function(){return new t.OrthographicCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglCylinderGeometry=k,e.VglPlaneGeometry={mixins:[T],props:{/** Width along the X axis. */width:{type:x,default:1},/** Height along the Y axis. */height:{type:x,default:1},/** Number of segments along the X axis. */widthSegments:{type:x,default:1},/** Number of segments along the Y axis. */heightSegments:{type:x,default:1}},computed:{inst:function(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},e.VglDodecahedronGeometry={mixins:[T],props:{/** Radius of the dodecahedron. */radius:{type:x,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:x,default:0}},computed:{inst:function(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglIcosahedronGeometry={mixins:[T],props:{/** Radius of the icosahedron. */radius:{type:x,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:x,default:0}},computed:{inst:function(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglOctahedronGeometry={mixins:[T],props:{/** Radius of the octahedron. */radius:{type:x,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:x,default:0}},computed:{inst:function(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglRingGeometry={mixins:[T],props:{/** Inner radius of the ring. */innerRadius:{type:x,default:.5},/** Outer radius of the ring. */outerRadius:{type:x,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:x,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:x,default:1},/** The starting angle. */thetaStart:{type:x,default:0},/** The central angle. */thetaLength:{type:x,default:2*v}},computed:{inst:function(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglTetrahedronGeometry={mixins:[T],props:{/** Radius of the tetrahedron. */radius:{type:x,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:x,default:0}},computed:{inst:function(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglTorusGeometry={mixins:[T],props:{/** Radius of the torus. */radius:{type:x,default:1},/** Diamiter of the tube. */tube:{type:x,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:x,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:x,default:6},/** The central angle. */arc:{type:x,default:2*v}},computed:{inst:function(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},e.VglTorusKnotGeometry={mixins:[T],props:{/** Radius of the torus. */radius:{type:x,default:1},/** Diamiter of the tube. */tube:{type:x,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:x,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:x,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:x,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:x,default:3}},computed:{inst:function(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},e.VglArrowHelper={mixins:[C],props:{/** Direction from origin. */dir:M,/** Length of the arrow. */length:{type:x,default:1},/** Color of the arrow. */color:{type:N,default:"#ff0"},/** The length of the head of the arrow. */headLength:x,/** The width of the head of the arrow. */headWidth:x},computed:{inst:function(){return new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3())},len:function(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler:function(e){this.dir&&e.setDirection(u(this.dir).normalize()),e.setLength.apply(e,n(this.len)),e.setColor(new t.Color(this.color))},immediate:!0},dir:function(e){this.inst.setDirection(u(e).normalize())},len:function(e){var t;(t=this.inst).setLength.apply(t,n(e))},color:function(e){this.inst.setColor(new t.Color(e))}}},e.VglBoxHelper={mixins:[C],props:{/** Size of the lines representing the axes. */color:{type:N,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:N},computed:{inst:function(){return new t.BoxHelper(void 0,this.color)}},methods:{setFromObject:function(){this.inst.setFromObject(this.vglNamespace.object3ds[this.object])}},created:function(){this.vglNamespace.beforeRender.push(this.setFromObject)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setFromObject;e.splice(e.indexOf(t),1)}},e.VglPointLight={mixins:[z],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:x,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:x,default:1}},computed:{inst:function(){return new t.PointLight}},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)}}},e.VglSpotLight={mixins:[z],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:x,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:x,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:x,default:v/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:x,default:0},/** The spotlight's pointing position. */target:M},computed:{inst:function(){return new t.SpotLight}},beforeDestroy:function(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(u(this.target)),this.vglObject3d.inst&&this.vglObject3d.inst.add(e.target)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst.target)},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)},angle:function(e){this.inst.angle=parseFloat(e)},penumbra:function(e){this.inst.penumbra=parseFloat(e)},target:function(e){this.inst.target.position.copy(u(e))}}},e.VglTexture={inject:["vglNamespace"],props:{/** The path or URL to the file. This can also be a Data URI. */src:N,name:N,mapping:{type:N,default:"uv"},wrapS:{type:N,default:"clamp-to-edge"},wrapT:{type:N,default:"clamp-to-edge"},magFilter:{type:N,default:"linear"},minFilter:{type:N,default:"linear-mip-map-linear"},anisotropy:{type:x,default:1},format:N,type:{type:N,default:"unsigned-byte"},offset:A,repeat:A,rotation:{type:x,default:0},center:A,premultiplyAlpha:V,unpackAlignment:{type:x,default:4},encoding:{type:N,default:"linear"}},computed:{inst:function(){var e=this;return new t.TextureLoader().load(this.src,function(t){e.format&&Object.assign(t,{format:I[e.format]}),e.vglNamespace.update()})}},watch:{inst:{handler:function(e){this.vglNamespace.textures[this.name]=e,Object.assign(e,{mapping:U[this.mapping],wrapS:W[this.wrapS],wrapT:W[this.wrapT],magFilter:_[this.magFilter],minFilter:_[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:q[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:K[this.encoding]}),this.offset&&e.offset.copy(g(this.offset)),this.repeat&&e.repeat.copy(g(this.repeat)),this.center&&e.center.copy(g(this.center))},immediate:!0},name:function(e,t){var i=this.vglNamespace.textures,a=this.inst;i[t]===a&&delete i[t],i[e]=a},mapping:function(e){this.inst.mapping=U[e]},wrapS:function(e){this.inst.wrapS=W[e]},wrapT:function(e){this.inst.wrapT=W[e]},magFilter:function(e){this.inst.magFilter=_[e]},minFilter:function(e){this.inst.minFilter=_[e]},anisotropy:function(e){this.inst.anisotropy=parseInt(e,10)},format:function(e){this.inst.format=I[e]},type:function(e){this.inst.type=q[e]},offset:function(e){this.inst.offset.copy(g(e))},repeat:function(e){this.inst.repeat.copy(g(e))},rotation:function(e){this.inst.rotation=parseFloat(e)},center:function(e){this.inst.center.copy(g(e))},premultiplyAlpha:function(e){this.inst.premultiplyAlpha=e},unpackAlignment:function(e){this.inst.unpackAlignment=parseInt(e,10)},encoding:function(e){this.inst.encoding=K[e]}},beforeDestroy:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.name;e[i]===t&&delete e[i]},beforeUpdate:function(){this.inst.needsUpdate=!0,this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},e.VglExtrudeGeometry=Q,e.VglTextGeometry={mixins:[Q],props:{/** The text that needs to be shown. */text:{type:N,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:N,/** Size of the text. */size:{type:x,default:100},/** Thickness to extrude text. */height:{type:x,default:50},/** Number of points on the curves. */curveSegments:{type:x,default:12},/** Turn on bevel. */bevelEnabled:V,/** How deep into text bevel goes. */bevelThickness:{type:x,default:10},/** How far from text outline is bevel. */bevelSize:{type:x,default:8},/** Number of bevel segments. */bevelSegments:{type:x,default:3}},data:function(){return{f:void 0}},computed:{inst:function(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:X[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler:function(e){var i=this;X[e]?X[e].isFont?this.f=e:X[e].push(function(){e===i.font&&(i.f=e)}):(X[e]=[function(){e===i.font&&(i.f=e),i.vglNamespace.update()}],new t.FontLoader().load(e,function(t){var i=X[e];X[e]=t,i.forEach(function(e){e()})}))},immediate:!0}}},e.VglSpriteMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The texture map of the material. */map:N},computed:{inst:function(){return new t.SpriteMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglGridHelper={mixins:[C],props:{/** The size of the grid. */size:{type:x,default:10},/** The number of divisions across the grid. */divisions:{type:x,default:10},/** The color of the centerline. */colorCenterLine:{type:N,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:N,default:"#888888"}},computed:{inst:function(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},e.VglShadowMaterial={mixins:[P],computed:{inst:function(){return new t.ShadowMaterial}}},e.VglCameraHelper={mixins:[C],props:{/** Name of the camera to visualize. */camera:N},methods:{setHelper:function(){if(!this.inst.children.length)this.inst.add(new t.CameraHelper(this.vglNamespace.cameras[this.camera]));else{var e=s(this.inst.children,1),i=e[0];i.camera=this.vglNamespace.cameras[this.camera],i.camera.updateProjectionMatrix(),i.update()}}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglDirectionalLightHelper={mixins:[C],props:{/** If this is not the set the helper will take the color of the light. */color:{type:N},/** Dimensions of the plane. */size:{type:x,default:1},/** Name of the directional light being visualized. */light:N},data:function(){return{s:void 0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var i=s(this.inst.children,1),a=i[0];if(a.light===e&&this.s===this.size)return a.color=this.color,void a.update();this.inst.remove(a)}this.s=this.size,this.inst.add(new t.DirectionalLightHelper(e,parseFloat(this.size),this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglPolarGridHelper={mixins:[C],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:x,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:x,default:16},/** The number of circles. This can be any positive integer. */circles:{type:x,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:x,default:64},/** The first color used for grid elements. */color1:{type:N,default:"#444444"},/** The second color used for grid elements. */color2:{type:N,default:"#888888"}},computed:{inst:function(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},e.VglMeshBasicMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The color map of the material. */map:N},computed:{inst:function(){return new t.MeshBasicMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshDepthMaterial={mixins:[H],props:{/** Whether the material is affected by fog. */fog:V,/** The color map of the material. */map:N},computed:{inst:function(){return new t.MeshDepthMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshLambertMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** The color map of the material. */map:N},computed:{inst:function(){return new t.MeshLambertMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglLineDashedMaterial={mixins:[P],props:{/** CSS style color of the material. */color:{type:N,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:V,/** The line thickness. */linewidth:{type:x,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:x,default:3},/** The size of the gap. */gapSize:{type:x,default:1}},computed:{inst:function(){return new t.LineDashedMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},dashSize:function(e){this.inst.dashSize=parseFloat(e)},gapSize:function(e){this.inst.gapSize=parseFloat(e)}}},e.VglMeshNormalMaterial={mixins:[P],props:{/** Whether the material is affected by fog. */fog:V},computed:{inst:function(){return new t.MeshNormalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshPhongMaterial=Y,e.VglMeshToonMaterial={mixins:[Y],computed:{inst:function(){return new t.MeshToonMaterial}}},e.VglMeshPhysicalMaterial={mixins:[O],props:{/** ClearCoat level, from 0.0 to 1.0. */clearCoat:{type:x,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearCoatRoughness:{type:x,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:x,default:.5}},computed:{inst:function(){return new t.MeshPhysicalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{clearCoat:parseFloat(this.clearCoat),clearCoatRoughness:parseFloat(this.clearCoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearCoat:function(e){this.inst.clearCoat=parseFloat(e)},clearCoatRoughness:function(e){this.inst.clearCoatRoughness=parseFloat(e)},reflectivity:function(e){this.inst.reflectivity=parseFloat(e)}}},e.VglLatheGeometry={mixins:[T],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:j,required:!0},/** The number of circumference segments to generate. */segments:{type:x,default:12},/** The starting angle in radians. */phiStart:{type:x,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:x,default:2*v}},computed:{inst:function(){return new t.LatheBufferGeometry(b(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},e.VglSpotLightHelper={mixins:[C],props:{/** If this is not the set the helper will take the color of the light. */color:{type:N},/** Name of the spot light being visualized. */light:N},methods:{setHelper:function(){if(this.inst.children.length){var e=s(this.inst.children,1),i=e[0];i.light===this.vglNamespace.object3ds[this.light]?(i.color=this.color,i.update()):(this.inst.remove(i),i.dispose(),this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color)))}else this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper,i=this.inst.children;e.splice(e.indexOf(t),1),i.length&&i[0].dispose()}},e.VglHemisphereLight={mixins:[z],props:{groundColor:{type:N,default:"#fff"}},computed:{inst:function(){return new t.HemisphereLight}},watch:{inst:{handler:function(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor:function(e){this.inst.groundColor.setStyle(e)}}},Object.defineProperty(e,"__esModule",{value:!0})});
