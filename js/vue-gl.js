(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):(e=e||self,t(e.VueGL={},e.THREE))})(this,function(e,t){'use strict';var p=Math.PI;/**
   * Returns a parsed quaternion object.
   */function i(e){return e.isQuaternion?e:new t.Quaternion(...e.trim().split(/\s+/).map(e=>parseFloat(e)))}/**
   * Returns a parsed vector3 object.
   */function a(e){return e.isVector3?e:new t.Vector3(...e.trim().split(/\s+/).map(e=>parseFloat(e)))}/**
   * Returns a parsed vector2 object.
   */function s(e){return e.isVector2?e:new t.Vector2(...e.trim().split(/\s+/).map(e=>parseFloat(e)))}/**
   * Returns a parsed euler object.
   */function r(e){return e.isEuler?e:new t.Euler(...e.trim().split(/\s+/).map((e,t)=>3===t?e:parseFloat(e)))}/**
   * Returns a parsed spherical object.
   */function n(e){return e.isSpherical?e:new t.Spherical(...e.trim().split(/\s+/).map(e=>parseFloat(e))).makeSafe()}/**
   * Returns a parsed array.
   */function o(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function l(e){return o(e).map(e=>s(e))}var d={inject:{vglNamespace:{default(){const e=[],t=[];let i;return{renderers:e,cameras:Object.create(null),scenes:Object.create(null),update:()=>{i||(this.$nextTick(()=>{t.forEach(e=>{e()}),e.forEach(e=>{e.render()}),i=!1}),i=!0)},beforeRender:t,geometries:Object.create(null),materials:Object.create(null),textures:Object.create(null),object3ds:Object.create(null)}}}},provide(){return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:Object.create(this.vglNamespace.geometries)},materials:{value:Object.create(this.vglNamespace.materials)},textures:{value:Object.create(this.vglNamespace.textures)},object3ds:{value:Object.create(this.vglNamespace.object3ds)}})}},render(e){return this.$slots.default?e("div",this.$slots.default):void 0}};const m=[String,Number],c=String,u=[String,t.Vector3],g=[String,t.Spherical],h=Boolean,f=[String,t.Euler],y=[String,t.Vector2],v=[String,t.Quaternion],b=[String,Array],S=[String,Array];/**
   * This is the base mixin component for most object components in VueGL,
   * corresponding [THREE.Object3D](https://threejs.org/docs/index.html#api/core/Object3D).
   * Object3d components inside a object3d component are added
   * as children via THREE.Object3D.prototype.add() method.
   *
   * VglObject3d components inside default slots are added as children.
   */var x={props:{/** The object's local position as a 3D vector. */position:u,/** The object's local rotation as a euler angle. */rotation:f,/**
       * The object's local rotation as a quaternion (specified in x, y, z, w order).
       * Do not use in conjunction with the rotation prop, since they both control the same property
       * of the underlying THREE.Object3D object.
       */rotationQuaternion:v,/** The object's local scale as a 3D vector. */scale:u,/** Whether the object gets rendered into shadow map. */castShadow:h,/** Whether the material receives shadows. */receiveShadow:h,/** Optional name of the object. */name:c,/** Whether the object is visible. */visible:{type:h,default:!0}},computed:{inst:()=>new t.Object3D},inject:{vglObject3d:{default:{}},vglNamespace:"vglNamespace"},provide(){const e=this;return{vglObject3d:{get inst(){return e.inst}}}},created(){this.vglNamespace.update()},beforeUpdate(){this.vglNamespace.update()},beforeDestroy(){const{vglNamespace:e,inst:t,name:i}=this;t.parent&&t.parent.remove(t),e.object3ds[i]===t&&delete e.object3ds[i],e.update()},watch:{inst:{handler(e,t){t&&t.parent&&t.parent.remove(t),this.vglObject3d.inst&&this.vglObject3d.inst.add(e),this.position&&e.position.copy(a(this.position)),this.rotation&&e.rotation.copy(r(this.rotation)),this.rotationQuaternion&&e.quaternion.copy(i(this.rotationQuaternion)),this.scale&&e.scale.copy(a(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow,visible:this.visible}),this.name!==void 0&&(this.vglNamespace.object3ds[this.name]=e)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst)},position(e){this.inst.position.copy(a(e))},rotation(e){this.inst.rotation.copy(r(e))},rotationQuaternion(e){this.inst.quaternion.copy(i(e))},scale(e){this.inst.scale.copy(a(e))},castShadow(e){this.inst.castShadow=e},receiveShadow(e){this.inst.receiveShadow=e},name(e,t){const{vglNamespace:{object3ds:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i},visible(e){this.inst.visible=e}},render(e){return this.$slots.default?e("div",this.$slots.default):void 0}},N={mixins:[x],computed:{inst:()=>new t.Scene},watch:{inst:{handler(e){this.vglNamespace.scenes[this.name]=e},immediate:!0},name(e,t){const{vglNamespace:{scenes:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i}},beforeDestroy(){const{vglNamespace:{scenes:t},inst:e}=this;t[this.name]===e&&delete t[this.name]}},M={mixins:[x],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:u,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:g},computed:{inst:()=>new t.Camera},watch:{inst:{handler(e){if(this.vglNamespace.cameras[this.name]=e,this.orbitPosition||this.orbitTarget){let i;this.orbitTarget&&(i=a(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(n(this.orbitPosition)),i&&e.position.add(i)),e.lookAt(i||new t.Vector3)}},immediate:!0},name(e,t){const{vglNamespace:{cameras:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i},orbitTarget(e){const t=a(e);this.orbitPosition&&this.inst.position.setFromSpherical(n(this.orbitPosition)).add(t),this.inst.lookAt(t)},orbitPosition(e){if(this.inst.position.setFromSpherical(n(e)),this.orbitTarget){const e=a(this.orbitTarget);this.inst.position.add(e),this.inst.lookAt(e)}else this.inst.lookAt(new t.Vector3)}},beforeDestroy(){const{vglNamespace:{cameras:t},inst:e}=this;t[this.name]===e&&delete t[this.name]}};/**
   * This is where you place objects,
   * corresponding [THREE.Scene](https://threejs.org/docs/index.html#api/scenes/Scene).
   *
   * Properties of [VglObject3d](vgl-object3d) are also available as mixin.
   */ /**
   * This component creates a canvas that have WebGL context.
   * Options are corresponding [THREE.WebGLRenderer](https://threejs.org/docs/index.html#api/core/Object3D).
   *
   * Properties of [VglNamespace](vgl-namespace) are also available as mixin.
   */var w={mixins:[d],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:c,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:h,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:h,/** Whether to perform antialiasing. */antialias:h,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:h,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:c,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:h,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:h,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:h,/** Name of the using camera. */camera:c,/** Name of the target scene. */scene:c,/** If set, use shadow maps in the scene. */shadowMapEnabled:h},computed:{inst(){const e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e},cameraInst(){if(this.camera!==void 0)return this.vglNamespace.cameras[this.camera];let e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(const t in this.vglNamespace.cameras){if(e)throw new ReferenceError("Cannot identify the camera. camera prop must be set when multiple cameras are defined.");e=this.vglNamespace.cameras[t]}return e},sceneInst(){if(this.scene!==void 0)return this.vglNamespace.scenes[this.scene];let e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(const t in this.vglNamespace.scenes){if(e)throw new ReferenceError("Cannot identify the scene. scene prop must be set when multiple scenes are defined.");e=this.vglNamespace.scenes[t]}return e}},methods:{render(){const{inst:e,cameraInst:t,sceneInst:i}=this;if(t&&i){if(t.isPerspectiveCamera){const e=this.$el.clientWidth/this.$el.clientHeight;t.aspect!==e&&(t.aspect=e,t.updateProjectionMatrix())}else if(t.isOrthographicCamera){const e=this.$el.clientWidth/2,i=this.$el.clientHeight/2;(t.right!==e||t.top!==i)&&(t.left=-e,t.right=e,t.top=i,t.bottom=-i,t.updateProjectionMatrix())}else throw new TypeError("Unknown camera type.");e.render(i,t)}}},watch:{inst(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.vglNamespace.update()),t.dispose()}},created(){this.vglNamespace.renderers.push(this)},mounted(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.appendChild(this.inst.domElement),this.vglNamespace.update()},beforeDestroy(){this.vglNamespace.renderers.splice(this.vglNamespace.renderers.indexOf(this),1),this.inst.dispose()},render(e){return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%",marginRight:"-100%",border:"none"},on:{load:e=>{e.target.contentWindow.addEventListener("resize",()=>{this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.vglNamespace.update()},!1)}}},this.$slots.default)])}},V={mixins:[M],props:{/** Zoom factor of the camera. */zoom:{type:m,default:1},/** Camera frustum near plane. */near:{type:m,default:.1},/** Camera frustum far plane. */far:{type:m,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:m,default:50}},computed:{inst:()=>new t.PerspectiveCamera},watch:{inst:{handler(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)}),e.updateProjectionMatrix()},immediate:!0},zoom(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()},fov(e){this.inst.fov=parseFloat(e),this.inst.updateProjectionMatrix()}}},L={mixins:[x],props:{/** CSS style color of the light. */color:{type:c,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:m,default:1}},computed:{inst:()=>new t.Light},watch:{inst:{handler(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color(e){this.inst.color.setStyle(e)},intensity(e){this.inst.intensity=parseFloat(e)}}};/**
   * Camera that uses perspective projection,
   * corresponding [THREE.PerspectiveCamera](https://threejs.org/docs/index.html#api/cameras/PerspectiveCamera).
   * Camera frustum aspect ratio is automatically set to the renderer aspect ratio.
   *
   * Properties of [VglCamera](vgl-camera) are also available as mixin.
   */const A={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},G={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide};/**
   * Abstract mixin component for materials,
   * corresponding [THREE.Material](https://threejs.org/docs/index.html#api/materials/Material).
   */var R={inject:["vglNamespace"],props:{/** Name of the material. */name:c,/** Defines which side of faces will be rendered. front, back or double. */side:{type:c,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:c,default:"no"}},computed:{inst:()=>new t.Material},watch:{inst:{handler(e){e.setValues({side:G[this.side],vertexColors:A[this.vertexColors]}),this.vglNamespace.materials[this.name]=e},immediate:!0},name(e,t){const{vglNamespace:{materials:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i},side(e){this.inst.side=G[e]},vertexColors(e){this.inst.vertexColors=A[e]}},beforeDestroy(){const{vglNamespace:{materials:t},inst:e}=this;t[this.name]===e&&delete t[this.name]},created(){this.vglNamespace.update()},beforeUpdate(){this.vglNamespace.update()},render(e){return this.$slots.default?e("div",this.$slots.default):void 0}},j={mixins:[R],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The size of the points. */size:{type:m,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:h},computed:{inst:()=>new t.PointsMaterial},watch:{inst:{handler(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)},size(e){this.inst.size=parseFloat(e)},disableSizeAttenuation(e){this.inst.sizeAttenuation=!e}}},C={inject:["vglNamespace"],props:{/** Name of the component. */name:c,/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:b,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:b,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:b},computed:{inst:()=>new t.BufferGeometry},watch:{inst:{handler(e,i){if(this.positionAttribute){const a=i?i.getAttribute("position"):new t.BufferAttribute(new Float32Array(o(this.positionAttribute)),3);e.addAttribute("position",a)}if(this.colorAttribute){const a=i?i.getAttribute("color"):new t.BufferAttribute(new Float32Array(o(this.colorAttribute)),3);e.addAttribute("color",a)}if(this.normalAttribute){const a=i?i.getAttribute("normal"):new t.BufferAttribute(new Float32Array(o(this.normalAttribute)),3);e.addAttribute("normal",a)}i&&i.dispose(),this.vglNamespace.geometries[this.name]=e},immediate:!0},name(e,t){const{vglNamespace:{geometries:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i},positionAttribute(e){const t=o(e),i=this.inst.getAttribute("position");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},colorAttribute(e){const t=o(e),i=this.inst.getAttribute("color");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},normalAttribute(e){const t=o(e),i=this.inst.getAttribute("normal");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0}},beforeDestroy(){const{vglNamespace:{geometries:t},inst:e}=this;t[this.name]===e&&delete t[this.name],e.dispose()},created(){this.vglNamespace.update()},beforeUpdate(){this.vglNamespace.update()},render(e){return this.$slots.default?e("div",this.$slots.default):void 0}},B={mixins:[C],props:{/** Sphere radius. */radius:{type:m,default:1},/** Number of horizontal segments. */widthSegments:{type:m,default:8},/** Number of vertical segments. */heightSegments:{type:m,default:6},/** Specify horizontal starting angle. */phiStart:{type:m,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:m,default:2*p},/** Specify vertical starting angle. */thetaStart:{type:m,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:m,default:p}},computed:{inst(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}};/**
   * The default material used by [VglPoints](vgl-points),
   * corresponding [THREE.PointsMaterial](https://threejs.org/docs/index.html#api/materials/PointsMaterial).
   *
   * Properties of [VglMaterial](vgl-material) are also available as mixin.
   */const z={mixins:[x],methods:{setMaterial(){const{vglNamespace:{materials:i},material:e,inst:t}=this;i[e]&&(t.material=i[e])}},created(){this.vglNamespace.beforeRender.unshift(this.setMaterial)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setMaterial:e}=this;t.splice(t.indexOf(e),1)}},P={mixins:[z],methods:{setGeometry(){const{vglNamespace:{geometries:i},geometry:e,inst:t}=this;i[e]&&(t.geometry=i[e])}},created(){this.vglNamespace.beforeRender.unshift(this.setGeometry)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setGeometry:e}=this;t.splice(t.indexOf(e),1)}},T={mixins:[R],methods:{setMap(){const{vglNamespace:{textures:i},inst:e,map:t}=this;t in i&&(e.map=i[t])}},created(){this.vglNamespace.beforeRender.unshift(this.setMap)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setMap:e}=this;t.splice(t.indexOf(e),1)}};/**
   * A standard physically based material,
   * corresponding [THREE.MeshStandardMaterial](https://threejs.org/docs/index.html#api/materials/MeshStandardMaterial).
   * Using Metallic-Roughness workflow.
   *
   * Properties of [VglMaterial](vgl-material) are also available as mixin.
   */var H={mixins:[T],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The color map of the material. */map:c},computed:{inst:()=>new t.MeshStandardMaterial},watch:{inst:{handler(e){e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)}}},E={mixins:[R],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:h,/** The line thickness. */linewidth:{type:m,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:c,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:c,default:"round"}},computed:{inst:()=>new t.LineBasicMaterial},watch:{inst:{handler(e){Object.assign(e,{lights:this.lights,linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)},lights(e){this.inst.lights=e},linewidth(e){this.inst.linewidth=parseFloat(e)},linecap(e){this.inst.linecap=e},linejoin(e){this.inst.linejoin=e}}},F={mixins:[P],props:{/** Name of the geometry, representing the line segment(s). */geometry:c,/** Name of the material for the line. */material:c},computed:{inst:()=>new t.Line},methods:{computeLineDistances(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},created(){this.vglNamespace.beforeRender.push(this.computeLineDistances)},beforeDestroy(){const{vglNamespace:{beforeRender:t},computeLineDistances:e}=this;t.splice(t.indexOf(e),1)}},D={mixins:[C],props:{/** Width of the sides on the X axis. */width:{type:m,default:1},/** Height of the sides on the Y axis. */height:{type:m,default:1},/** Depth of the sides on the Z axis. */depth:{type:m,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:m,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:m,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:m,default:1}},computed:{inst(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},O={mixins:[C],props:{/** Radius of the circle. */radius:{type:m,default:1},/** Number of segments (triangles). */segments:{type:m,default:8},/** Start angle for first segment. */thetaStart:{type:m,default:0},/** The central angle of the circular sector. */thetaLength:{type:m,default:2*p}},computed:{inst(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},$={mixins:[C],props:{/** Radius of the cylinder at the top. */radiusTop:{type:m,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:m,default:1},/** Height of the cylinder. */height:{type:m,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:m,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:m,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:h,/** Start angle for first segment. */thetaStart:{type:m,default:0},/** The central angle of the circular sector. */thetaLength:{type:m,default:2*p}},computed:{inst(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},k={mixins:[$],props:{/** Radius of the cone at the base. */radius:{type:m,default:1}},computed:{inst(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},U={mixins:[x],props:{/** Size of the lines representing the axes. */size:{type:m,default:1}},computed:{inst(){return new t.AxesHelper(parseFloat(this.size))}}},W={mixins:[M],props:{/** Zoom factor of the camera. */zoom:{type:m,default:1},/** Camera frustum near plane. */near:{type:m,default:.1},/** Camera frustum far plane. */far:{type:m,default:2e3}},computed:{inst:()=>new t.OrthographicCamera},watch:{inst:{handler(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)}),e.updateProjectionMatrix()},immediate:!0},zoom(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()}}},q={mixins:[C],props:{/** Width along the X axis. */width:{type:m,default:1},/** Height along the Y axis. */height:{type:m,default:1},/** Number of segments along the X axis. */widthSegments:{type:m,default:1},/** Number of segments along the Y axis. */heightSegments:{type:m,default:1}},computed:{inst(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},I={mixins:[C],props:{/** Radius of the dodecahedron. */radius:{type:m,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:m,default:0}},computed:{inst(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},Q={mixins:[C],props:{/** Radius of the icosahedron. */radius:{type:m,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:m,default:0}},computed:{inst(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},_={mixins:[C],props:{/** Radius of the octahedron. */radius:{type:m,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:m,default:0}},computed:{inst(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},K={mixins:[C],props:{/** Inner radius of the ring. */innerRadius:{type:m,default:.5},/** Outer radius of the ring. */outerRadius:{type:m,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:m,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:m,default:1},/** The starting angle. */thetaStart:{type:m,default:0},/** The central angle. */thetaLength:{type:m,default:2*p}},computed:{inst(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},Y={mixins:[C],props:{/** Radius of the tetrahedron. */radius:{type:m,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:m,default:0}},computed:{inst(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},Z={mixins:[C],props:{/** Radius of the torus. */radius:{type:m,default:1},/** Diamiter of the tube. */tube:{type:m,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:m,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:m,default:6},/** The central angle. */arc:{type:m,default:2*p}},computed:{inst(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},X={mixins:[C],props:{/** Radius of the torus. */radius:{type:m,default:1},/** Diamiter of the tube. */tube:{type:m,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:m,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:m,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:m,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:m,default:3}},computed:{inst(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},J={mixins:[x],props:{/** Direction from origin. */dir:u,/** Length of the arrow. */length:{type:m,default:1},/** Color of the arrow. */color:{type:c,default:"#ff0"},/** The length of the head of the arrow. */headLength:m,/** The width of the head of the arrow. */headWidth:m},computed:{inst:()=>new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3()),len(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler(e){this.dir&&e.setDirection(a(this.dir).normalize()),e.setLength(...this.len),e.setColor(new t.Color(this.color))},immediate:!0},dir(e){this.inst.setDirection(a(e).normalize())},len(e){this.inst.setLength(...e)},color(e){this.inst.setColor(new t.Color(e))}}},ee={mixins:[x],props:{/** Size of the lines representing the axes. */color:{type:c,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:c},computed:{inst(){return new t.BoxHelper(void 0,this.color)}},methods:{setFromObject(){this.inst.setFromObject(this.vglNamespace.object3ds[this.object])}},created(){this.vglNamespace.beforeRender.push(this.setFromObject)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setFromObject:e}=this;t.splice(t.indexOf(e),1)}},te={mixins:[L],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:m,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:m,default:1}},computed:{inst:()=>new t.PointLight},watch:{inst:{handler(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance(e){this.inst.distance=parseFloat(e)},decay(e){this.inst.decay=parseFloat(e)}}},ie={mixins:[L],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:m,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:m,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:m,default:p/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:m,default:0},/** The spotlight's pointing position. */target:u},computed:{inst:()=>new t.SpotLight},beforeDestroy(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(a(this.target)),this.vglObject3d.inst&&this.vglObject3d.inst.add(e.target)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst.target)},distance(e){this.inst.distance=parseFloat(e)},decay(e){this.inst.decay=parseFloat(e)},angle(e){this.inst.angle=parseFloat(e)},penumbra(e){this.inst.penumbra=parseFloat(e)},target(e){this.inst.target.position.copy(a(e))}}};/**
   * A component representing triangular polygon mesh based objects,
   * corresponding [THREE.Mesh](https://threejs.org/docs/index.html#api/objects/Mesh).
   *
   * Properties of [VglObject3d](vgl-object3d) are also available as mixin.
   */const ae={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},se={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},re={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},ne={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},oe={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},le={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking};/**
   * A texture to apply to a surface or as a reflection or refraction map,
   * corresponding [THREE.Texture](https://threejs.org/docs/index.html#api/textures/Texture).
   */var pe={inject:["vglNamespace"],props:{/** The path or URL to the file. This can also be a Data URI. */src:c,name:c,mapping:{type:c,default:"uv"},wrapS:{type:c,default:"clamp-to-edge"},wrapT:{type:c,default:"clamp-to-edge"},magFilter:{type:c,default:"linear"},minFilter:{type:c,default:"linear-mip-map-linear"},anisotropy:{type:m,default:1},format:c,type:{type:c,default:"unsigned-byte"},offset:y,repeat:y,rotation:{type:m,default:0},center:y,premultiplyAlpha:h,unpackAlignment:{type:m,default:4},encoding:{type:c,default:"linear"}},computed:{inst(){return new t.TextureLoader().load(this.src,e=>{this.format&&Object.assign(e,{format:ne[this.format]}),this.vglNamespace.update()})}},watch:{inst:{handler(e){this.vglNamespace.textures[this.name]=e,Object.assign(e,{mapping:ae[this.mapping],wrapS:se[this.wrapS],wrapT:se[this.wrapT],magFilter:re[this.magFilter],minFilter:re[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:oe[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:le[this.encoding]}),this.offset&&e.offset.copy(s(this.offset)),this.repeat&&e.repeat.copy(s(this.repeat)),this.center&&e.center.copy(s(this.center))},immediate:!0},name(e,t){const{vglNamespace:{textures:a},inst:i}=this;a[t]===i&&delete a[t],a[e]=i},mapping(e){this.inst.mapping=ae[e]},wrapS(e){this.inst.wrapS=se[e]},wrapT(e){this.inst.wrapT=se[e]},magFilter(e){this.inst.magFilter=re[e]},minFilter(e){this.inst.minFilter=re[e]},anisotropy(e){this.inst.anisotropy=parseInt(e,10)},format(e){this.inst.format=ne[e]},type(e){this.inst.type=oe[e]},offset(e){this.inst.offset.copy(s(e))},repeat(e){this.inst.repeat.copy(s(e))},rotation(e){this.inst.rotation=parseFloat(e)},center(e){this.inst.center.copy(s(e))},premultiplyAlpha(e){this.inst.premultiplyAlpha=e},unpackAlignment(e){this.inst.unpackAlignment=parseInt(e,10)},encoding(e){this.inst.encoding=le[e]}},beforeDestroy(){const{vglNamespace:{textures:i},inst:e,name:t}=this;i[t]===e&&delete i[t]},beforeUpdate(){this.inst.needsUpdate=!0,this.vglNamespace.update()},render(e){return this.$slots.default?e("div",this.$slots.default):void 0}},de={mixins:[C],computed:{inst(){return new t.ExtrudeBufferGeometry([],{})}}};/**
   * A component for creating extruded geometry from a path shape,
   * corresponding [THREE.ExtrudeGeometry](https://threejs.org/docs/index.html#api/geometries/ExtrudeGeometry).
   *
   * Properties of [VglGeometry](vgl-geometry) are also available as mixin.
   */const me=Object.create(null);/**
   * A component for generating text as a single geometry,
   * corresponding [THREE.TextGeometry](https://threejs.org/docs/index.html#api/geometries/TextGeometry).
   *
   * Properties of [VglGeometry](vgl-geometry) are also available as mixin.
   */var ce={mixins:[de],props:{/** The text that needs to be shown. */text:{type:c,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:c,/** Size of the text. */size:{type:m,default:100},/** Thickness to extrude text. */height:{type:m,default:50},/** Number of points on the curves. */curveSegments:{type:m,default:12},/** Turn on bevel. */bevelEnabled:h,/** How deep into text bevel goes. */bevelThickness:{type:m,default:10},/** How far from text outline is bevel. */bevelSize:{type:m,default:8},/** Number of bevel segments. */bevelSegments:{type:m,default:3}},data(){return{f:void 0}},computed:{inst(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:me[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler(e){me[e]?me[e].isFont?this.f=e:me[e].push(()=>{e===this.font&&(this.f=e)}):(me[e]=[()=>{e===this.font&&(this.f=e),this.vglNamespace.update()}],new t.FontLoader().load(e,t=>{const i=me[e];me[e]=t,i.forEach(e=>{e()})}))},immediate:!0}}},ue={mixins:[T],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The texture map of the material. */map:c},computed:{inst:()=>new t.SpriteMaterial},watch:{inst:{handler(e){e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)}}},ge={mixins:[x],props:{/** The size of the grid. */size:{type:m,default:10},/** The number of divisions across the grid. */divisions:{type:m,default:10},/** The color of the centerline. */colorCenterLine:{type:c,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:c,default:"#888888"}},computed:{inst(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},he={mixins:[x],props:{/** Name of the camera to visualize. */camera:c},methods:{setHelper(){if(!this.inst.children.length)this.inst.add(new t.CameraHelper(this.vglNamespace.cameras[this.camera]));else{const[e]=this.inst.children;e.camera=this.vglNamespace.cameras[this.camera],e.camera.updateProjectionMatrix(),e.update()}}},created(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setHelper:e}=this;t.splice(t.indexOf(e),1)}},fe={mixins:[x],props:{/** If this is not the set the helper will take the color of the light. */color:{type:c},/** Dimensions of the plane. */size:{type:m,default:1},/** Name of the directional light being visualized. */light:c},data(){return{s:void 0}},methods:{setHelper(){const e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){const[t]=this.inst.children;if(t.light===e&&this.s===this.size)return t.color=this.color,void t.update();this.inst.remove(t)}this.s=this.size,this.inst.add(new t.DirectionalLightHelper(e,parseFloat(this.size),this.color))}},created(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setHelper:e}=this;t.splice(t.indexOf(e),1)}},ye={mixins:[x],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:m,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:m,default:16},/** The number of circles. This can be any positive integer. */circles:{type:m,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:m,default:64},/** The first color used for grid elements. */color1:{type:c,default:"#444444"},/** The second color used for grid elements. */color2:{type:c,default:"#888888"}},computed:{inst(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},ve={mixins:[x],props:{/** If this is not the set the helper will take the color of the light. */color:{type:c},/** Name of the RectAreaLight being visualized. */light:{type:c,required:!0}},methods:{setHelper(){const e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){const[t]=this.inst.children;if(t.light===e)return t.color=this.color,void t.update();this.inst.remove(t)}this.inst.add(new t.RectAreaLightHelper(e,this.color))}},created(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setHelper:e}=this;t.splice(t.indexOf(e),1)}},be={mixins:[T],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The color map of the material. */map:c},computed:{inst:()=>new t.MeshBasicMaterial},watch:{inst:{handler(e){e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)}}},Se={mixins:[T],props:{/** Whether the material is affected by fog. */fog:h,/** The color map of the material. */map:c},computed:{inst:()=>new t.MeshDepthMaterial},watch:{inst:{handler(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog(e){this.inst.fog=e}}},xe={mixins:[T],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The color map of the material. */map:c},computed:{inst:()=>new t.MeshLambertMaterial},watch:{inst:{handler(e){e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)}}},Ne={mixins:[R],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:h,/** The line thickness. */linewidth:{type:m,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:m,default:3},/** The size of the gap. */gapSize:{type:m,default:1}},computed:{inst:()=>new t.LineDashedMaterial},watch:{inst:{handler(e){Object.assign(e,{lights:this.lights,dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)},lights(e){this.inst.lights=e},linewidth(e){this.inst.linewidth=parseFloat(e)},dashSize(e){this.inst.dashSize=parseFloat(e)},gapSize(e){this.inst.gapSize=parseFloat(e)}}},Me={mixins:[R],props:{/** Whether the material is affected by fog. */fog:h},computed:{inst:()=>new t.MeshNormalMaterial},watch:{inst:{handler(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog(e){this.inst.fog=e}}},we={mixins:[T],props:{/** CSS style color of the material. */color:{type:c,default:"#fff"},/** The color map of the material. */map:c,/** Specular color of the material. */specular:{type:c,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:m,default:30}},computed:{inst:()=>new t.MeshPhongMaterial},watch:{inst:{handler(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color(e){this.inst.color.setStyle(e)},specular(e){this.inst.specular.setStyle(e)},shininess(e){this.inst.shininess=parseFloat(e)}}},Ve={mixins:[H],props:{/** ClearCoat level, from 0.0 to 1.0. */clearCoat:{type:m,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearCoatRoughness:{type:m,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:m,default:.5}},computed:{inst:()=>new t.MeshPhysicalMaterial},watch:{inst:{handler(e){Object.assign(e,{clearCoat:parseFloat(this.clearCoat),clearCoatRoughness:parseFloat(this.clearCoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearCoat(e){this.inst.clearCoat=parseFloat(e)},clearCoatRoughness(e){this.inst.clearCoatRoughness=parseFloat(e)},reflectivity(e){this.inst.reflectivity=parseFloat(e)}}},Le={mixins:[C],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:S,required:!0},/** The number of circumference segments to generate. */segments:{type:m,default:12},/** The starting angle in radians. */phiStart:{type:m,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:m,default:2*p}},computed:{inst(){return new t.LatheBufferGeometry(l(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},Ae={mixins:[x],props:{/** If this is not the set the helper will take the color of the light. */color:{type:c},/** Name of the spot light being visualized. */light:c},methods:{setHelper(){if(this.inst.children.length){const[e]=this.inst.children;e.light===this.vglNamespace.object3ds[this.light]?(e.color=this.color,e.update()):(this.inst.remove(e),e.dispose(),this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color)))}else this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color))}},created(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy(){const{vglNamespace:{beforeRender:t},setHelper:e,inst:{children:i}}=this;t.splice(t.indexOf(e),1),i.length&&i[0].dispose()}},Ge={mixins:[L],props:{groundColor:{type:c,default:"#fff"}},computed:{inst:()=>new t.HemisphereLight},watch:{inst:{handler(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor(e){this.inst.groundColor.setStyle(e)}}},Re={mixins:[L],props:{/** Width of the light. */width:{type:m,default:10},/** Height of the light. */height:{type:m,default:10}},computed:{inst:()=>new t.RectAreaLight},watch:{inst:{handler(e){Object.assign(e,{width:parseFloat(this.width),height:parseFloat(this.height)})},immediate:!0},width(e){this.inst.width=parseFloat(e)},height(e){this.inst.height=parseFloat(e)}}};/**
   * A material for a use with a [VglSprite](vgl-sprite) component,
   * corresponding [THREE.SpriteMaterial](https://threejs.org/docs/index.html#api/materials/SpriteMaterial).
   *
   * Properties of [VglMaterial](vgl-material) are also available as mixin.
   */e.VglNamespace=d,e.VglObject3d=x,e.VglScene=N,e.VglCamera=M,e.VglRenderer=w,e.VglPerspectiveCamera=V,e.VglGroup={mixins:[x],computed:{inst:()=>new t.Group}},e.VglLight=L,e.VglDirectionalLight={mixins:[L],computed:{inst:()=>new t.DirectionalLight}},e.VglAmbientLight={mixins:[L],computed:{inst:()=>new t.AmbientLight}},e.VglMaterial=R,e.VglPointsMaterial=j,e.VglGeometry=C,e.VglSphereGeometry=B,e.VglMeshStandardMaterial=H,e.VglMesh={mixins:[P],props:{/** Name of the geometry, defining the object's structure. */geometry:c,/** Name of the material, defining the object's appearance. */material:c},computed:{inst:()=>new t.Mesh}},e.VglPoints={mixins:[P],props:{/** Name of the geometry, defining the object's structure. */geometry:c,/** Name of the material, defining the object's appearance. */material:c},computed:{inst:()=>new t.Points}},e.VglLineBasicMaterial=E,e.VglLine=F,e.VglSprite={mixins:[z],props:{/** Name of the material, defining the object's appearance. */material:c},computed:{inst:()=>new t.Sprite}},e.VglBoxGeometry=D,e.VglCircleGeometry=O,e.VglLineSegments={mixins:[F],computed:{inst:()=>new t.LineSegments}},e.VglLineLoop={mixins:[F],computed:{inst:()=>new t.LineLoop}},e.VglConeGeometry=k,e.VglAxesHelper=U,e.VglOrthographicCamera=W,e.VglCylinderGeometry=$,e.VglPlaneGeometry=q,e.VglDodecahedronGeometry=I,e.VglIcosahedronGeometry=Q,e.VglOctahedronGeometry=_,e.VglRingGeometry=K,e.VglTetrahedronGeometry=Y,e.VglTorusGeometry=Z,e.VglTorusKnotGeometry=X,e.VglArrowHelper=J,e.VglBoxHelper=ee,e.VglPointLight=te,e.VglSpotLight=ie,e.VglTexture=pe,e.VglExtrudeGeometry=de,e.VglTextGeometry=ce,e.VglSpriteMaterial=ue,e.VglGridHelper=ge,e.VglShadowMaterial={mixins:[R],computed:{inst:()=>new t.ShadowMaterial}},e.VglCameraHelper=he,e.VglDirectionalLightHelper=fe,e.VglPolarGridHelper=ye,e.VglRectAreaLightHelper=ve,e.VglMeshBasicMaterial=be,e.VglMeshDepthMaterial=Se,e.VglMeshLambertMaterial=xe,e.VglLineDashedMaterial=Ne,e.VglMeshNormalMaterial=Me,e.VglMeshPhongMaterial=we,e.VglMeshToonMaterial={mixins:[we],computed:{inst:()=>new t.MeshToonMaterial}},e.VglMeshPhysicalMaterial=Ve,e.VglLatheGeometry=Le,e.VglSpotLightHelper=Ae,e.VglHemisphereLight=Ge,e.VglRectAreaLight=Re,Object.defineProperty(e,"__esModule",{value:!0})});
